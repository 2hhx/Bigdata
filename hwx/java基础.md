# Java基础 #
**1、是否可以在static环境中访问非static变量？**

因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态成员
**故：**在static方法中创建实例就可以调用了，比如main函数就是static的，在里面可以new实例，然后调相应的方法

**2、Java支持的数据类型有哪些？什么是自动拆装箱？**
基本数据类型：
整数值型：byte,short,int,long。
字符型：char。
浮点类型：float,double。
布尔型：boolean。

整数默认int型，小数默认是**double**型。Float和long类型的**必须加后缀。**。

注：首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，**实体在堆中**。引用类型包括类、接口、数组等。String类还是final修饰的。
 而包装类就属于引用类型，自动装箱和拆箱就是**基本类型和引用类型**之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，**泛型的限定类型只能是对应的包装类型。**

**3、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？**

**方法重写的原则：**

重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也**可以是原类型的子类型**(从Java SE5开始支持)。
重写方法不能比原方法访问性差（即访问权限不允许缩小）。
重写方法不能比原方法抛出更多的异常。
被重写的方法不能是final类型，因为final修饰的方法是无法重写的。
被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。
被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。
**重写是发生在运行时的**，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。

**方法重载的原则：**
方法名称必须相同。
参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。
方法的返回类型可以相同也可以不相同。
仅仅返回类型不同不足以成为方法的重载。
重载是**发生在编译时**的，因为编译器可以根据参数的类型来选择使用哪个方法。

** 重写和重载的不同：**

方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。
方法重写要求返回类型必须一致(**或为其子类型**)，方法重载对此没有要求。
方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法。
方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。
重载是编译时多态，重写是运行时多态。

**4、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？**

当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。
Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。
**Java不支持像C++中那样的复制构造方法**，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。

**5、Java支持多继承么？**
Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 **但是java中的接口支持多继承**，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。

**6、接口和抽象类的区别是什么？**
Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
**类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。**
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。
也可以参考JDK8中抽象类和接口的区别

**一句话总结：**从设计层面来讲，抽象是对类的抽象，是一种模板设计；接口是**行为**的抽象，是一种行为的规范

**7、什么是值传递和引用传递？**

值传递是对**基本型变量**而言的,传递的是该变量的一个副本,改变副本不影响原变量.
引用传递一般是对于**对象型变量**而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。
一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递

**注：这篇解释的很好：**
https://www.zhihu.com/question/31203609/answer/50992895
