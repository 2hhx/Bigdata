# 数组 #
**实现**
在数组之后新增一个元素（数组不可扩充）
**步骤**
1.创建一个新数组，将原来的数组拷贝至新数组
2.在新数组最后增加一个元素（length-1）
3.覆盖原有数组
# 查找算法 #
## 线性查找 ##
**实现**
遍历数组，将目标元素与数组元素一一对比，全找不到则返回-1（遍历过程中如果数组数=目标数，则返回下标）
## 二分法查找 ##
**实现**
每次取出中间数，看左右两边的取值
**步骤**
1.定义开始，结束，中间的索引
2.判断中间元素是否是查找的元素（否则执行第三步）
3.判断中间元素与目标元素大小
4.大则调整end，小则调整begin
5.取出新的中间位置，循环以上
# 栈 #（箱子，弹夹）
**压栈实现**
1.创建新的数组（长度为旧数组+1）
2.将旧数组赋值到新数组中（元素复制）
3.将需要添加的元素放入新数组的最后一位中
4.使用新数组替换旧数组
**弹出**
1.取出数组最后一个元素进行保存为栈顶元素
2.建立新数组，长度为旧数组-1
3.除最后一个元素，其他的元素都放入新的数组
4.替换数组
5.返回保存的栈顶元素
# 队列 #
**入队**
与压栈一致
**出队**
1.创建一个新的数组，长度为旧数组-1
2.取出数组中第0个元素进行保存为队头
3.复制原数组中的元素到新数组（a2[i]=a1[i+1]）
4.替换数组
5.返回保存的队头
#单（循环）链表#
**append**
1.取出当前节点
2.取出下一个节点赋给当前节点
3.把需追加的节点追加到当前节点的下一个节点
**after**
1.取出下一个节点为下下个节点
2.把新节点作为当前节点的下一节点
3.把下下节点设为新节点的下一个节点
# 双向（**双向循环**）列表 #
1的下一节点为2,2的前一节点为1**&&1的前一个节点为2,2的下一个节点为1**
1的下一节点为2,2的前一节点为1&&3的前一个节点为2,2的下一个节点为3&&**1的前一个节点为3,3的下一个节点为1**
# 排序算法 #
## 交换排序 ##
### 冒泡排序 ###
**实现思路**
两两比较，大的向后移动
**实现步骤**
	for(i<arr.length-1)//一共比较多少轮
		for(j<arr.length-i)//一共比较多少次
			if(arr[j]>arr[j-1])//两两比较
				交换
### 快速排序 ###
**实现思路**
递归进行左右俩边的数字交换
**实现代码**
    		if(start<end) {
			//把数组中的第0个数字做为标准数
			int stard=arr[start];
			//记录需要排序的开始和结束下标
			int low=start;
			int high=end;
			//循环找比标准数大的数和比标准数小的数
			while(low<high) {
				//右边的数字比标准数大
				while(low<high&&stard<=arr[high]) {
				//则右边的下标--，代表下标位置向左边移动一位
					high--;
				}
				//如果最右边的数字比标准数小，使用右边的数字替换左边的数字
				arr[low]=arr[high];
				//如果左边的数字比标准数小
				while(low<high&&arr[low]<=stard) {
               //则左边的下标++，代表下标位置向右边移动一位
					low++;
				}
               //如果最左边的数字比标准数小，使用左边的数字替换右边的数字
				arr[high]=arr[low];
			}
			//把标准数赋给低所在的位置的元素
			arr[low]=stard;
			//处理所有的小的数字
			quickSort(arr, start, low);
			//处理所有的大的数字
			quickSort(arr, low+1, end);
## 插入排序 ##
### 直接插入排序 ###
**实现思路**
从第1个元素开始，与前面的数字进行对比，如果小于前面数字，则交换位置
**实现步骤**
    //遍历所有的数字
		for(int i=1;i<arr.length;i++) {
			//如果当前数字比前一个数字小
			if(arr[i]<arr[i-1]) {
				//把当前遍历数字存起来|需要拿着去跟别人比较的元素
				int temp=arr[i];
				int j;
				//遍历当前数字前面所有的数字
				for(j=i-1;j>=0&&temp<arr[j];j--) {
					//把前一个数字赋给后一个数字|大于临时变量，则元素向后移动
					arr[j+1]=arr[j];
				}
				//把临时变量（外层for循环的当前元素）赋给不满足条件的后一个元素|直到大于或者等于，进行赋值
				arr[j+1]=temp;
### 希尔排序 ###
**实现思路**
元素个数/2为步数，循环一次再除以2，直到步长<=0，循环比较当前元素和当前元素加上步数的元素的大小
**实现代码**
    // 遍历所有的步长
		for (int d = arr.length / 2; d > 0; d /= 2) {
			// 遍历所有有元素
			for (int i = d; i < arr.length; i++) {
				// 遍历本组中所有的元素
				for (int j = i - d; j >= 0; j -= d) {
					// 如果当前元素大于加上步长后的那个元素
					if (arr[j] > arr[j + d]) {
						int temp = arr[j];
						arr[j] = arr[j + d];
						arr[j + d] = temp;
					}
				}
## 选择排序 ##
### 简单选择排序 ###

### 堆排序 ###

## 归并排序 ##

## 基数排序 ##